<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github如何同步更新一个你Fork的仓库？]]></title>
    <url>%2F2018%2F06%2F12%2FGithub-%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AA%E4%BD%A0Fork%E7%9A%84%E4%BB%93%E5%BA%93%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[我们在进行Github协同开发的时候，往往会去fork一个仓库到自己的Github中，过一段时间以后，原仓库可能会有各种提交以及修改，很可惜，Github本身并没有自动进行同步的机制，这个需要我们手动去执行，现在我来演示一下如何进行自己的仓库和原仓库进行Gith同步的操作。重点在于：除了origin以外，增加一个upstream，来跟踪原仓库的更新。 先将你fork到自己的Github的远程仓库克隆到本地1$ git clone https://github.com/zmzhouXJTU/Problem-sets 查看远程仓库的信息123$ git remote -vorigin https://github.com/zmzhouXJTU/Problem-sets (fetch)origin https://github.com/zmzhouXJTU/Problem-sets (push) 配置原远程仓库(即你所fork的)的路径1$ git remote add upstream https://github.com/ACLoong/Problem-sets 再次查看远程仓库信息确定是否配置成功12345$ git remote -vorigin https://github.com/zmzhouXJTU/Problem-sets (fetch)origin https://github.com/zmzhouXJTU/Problem-sets (push)upstream https://github.com/ACLoong/Problem-sets (fetch)upstream https://github.com/ACLoong/Problem-sets (push) 抓取原仓库的更新文件，该文件会被存储在一个本地分支upstream/master上1234567$ git fetch upstreamremote: Counting objects: 21, done.remote: Compressing objects: 100% (15/15), done.remote: Total 21 (delta 4), reused 5 (delta 1), pack-reused 0Unpacking objects: 100% (21/21), done.From https://github.com/ACLoong/Problem-sets * [new branch] master -&gt; upstream/master 切换到本地主分支(如果当前不在的话)12$ git checkout master# Switched to branch 'master' 将原仓库的更新文件(即存储在本地的upstream/master分支上的文件)与本地仓库的当前分支合并123456$ git merge upstream/masterUpdating 60b537a..426148cFast-forward problem_set/first_week/refs/Process&amp;Thread.md | 29 +++++++++++++++++++++++++++ 1 file changed, 29 insertions(+) create mode 100644 problem_set/first_week/refs/Process&amp;Thread.md Note: 此时，你的本地仓库已经和原来仓库完全同步了。但是注意，此时只是你电脑上的本地仓库和原作者的远程github仓库同步了，你fork到自己的github远程仓库还没有同步。要想实现本地和自己的Github远程仓库的同步，只需要如下操作即可： 将其更新到自己的Github远程仓库，可以利用命令git push origin master来实现123456789$ git push origin masterCounting objects: 21, done.Delta compression using up to 4 threads.Compressing objects: 100% (16/16), done.Writing objects: 100% (21/21), 5.65 KiB | 1.88 MiB/s, done.Total 21 (delta 4), reused 0 (delta 0)remote: Resolving deltas: 100% (4/4), completed with 2 local objects.To https://github.com/zmzhouXJTU/Problem-sets 60b537a..426148c master -&gt; master 好了，至此任务就完成了。不知你是否看明白了呢？有任何问题，欢迎在此博客下方评论留言。]]></content>
      <categories>
        <category>版本控制之Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件权限]]></title>
    <url>%2F2018%2F04%2F26%2FLinux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[在 Linux 操作系统中，权限是一个非常重要的东西。 它无时无刻不在影响着你的各种操作。就像有的时候，你想去百度云下载一些别人分享的文件，可是你却发现虽然你能看到文件但是你却不能下载，这就是一种权限的典型例子。在 Linux 中, 这种权限随处可见。你可以设置，让别人不能越界。 不过像我这种人，也就是一台电脑， 一个用户(手动滑稽)，涉及不到多少有关权限方面的问题。 如果你也和我差不多，只有你自己在用 Linux 的电脑，主要用它来运行你的代码。我教你一招来修改权限，并且方便运行你的 Python 脚本的招数。 这里不会涉及过深的权限管理。我们了解一些基础，方便你拿你的 Linux 跑机器学习的代码就好。如果你想扩展学习的话, 网上会有很多教程。可以自行谷歌。 ls查看权限查看文件权限的方法很简单，其实在之前我的上一篇博文就讲了这个内容。 如果你还记得的话，我们在说 ls指令的时候, 提到过权限问题， 不过到了这节内容我们仔细的来说一说权限。如果你在 Terminal 中输入如下图片中的指令： 如上图所示，在 Terminal 中查看文件的权限的命令可以用ls -l 或者ls -lh，这个是看当前目录下面所有文件的权限，如果你只是想单独看看某一个具体的文件的权限，只需要在后面加上相应的文件名就可以了，比如ls -lh p1.py。 我们看到的上图中的-rw-rw-r--就是相关的权限啦。那么这些具体又是表达什么意思的呢？看下面的图就明白啦。 Type: 很多种 (最常见的是 - 为文件, d 为文件夹, 其他的还有l, n … 这种东西, 真正自己遇到了, 网上再搜就好, 一次性说太多记不住的)。 User: 后面跟着的三个空是使用 User 的身份能对这个做什么处理 (r 可读; w 可写; x 可执行; - 不能完成某个操作)。 Group: 一个 Group 里可能有一个或者多个 user, 这些权限的样式和 User 一样。 Others: 除了 User 和 Group 以外人的权限。 如果有人对 User, group, others 这三个没什么概念的话，我这里补充一下。User 一般就是指你，这个当前正在使用电脑的人。 Group 是一个 User 的集合，最开始创建新 User 的时候, 他也为这个 User 创建了一个和 User 一样名字的 Group, 这个新 Group 里只有这个 User。一般来说，像一个企业部门的电脑，都可以放在一个 Group 里, 分享了一些共享文件和权限。Others 就是除了上面提到的 User 和 Group 以外的人。 好了, 有了这些理解, 我们拿上面的 p1.py 来举例. 我们可以将 -rw-rw-r-- 拆成 - (这是文件), -rw(这个 User可以读,写), rw- (这个Group里可以读,写), r– (其他人只能读)。 chmod 修改权限好了, 我们知道了这些权限的问题, 那我们如何来改写权限呢? chmod (change mode)命令就是来干这个的。 通常的修改形式是： 1~$ chmod [谁] [怎么修改] [哪个文件] 举个最简单的例子, 现在的 p1.py 的权限是 -rw-rw-r--, 如果我们想让user和group拥有执行的能力。按照下面这样来改就行了。相应的结果如下图所示： 这里的 ug+x 很形象, User,Group + execute , 给 p1.py 这个文件进行修改。所以我们的修改形式就能总结出下面这样： [谁] u: 对于 User 修改 g: 对于 Group 修改 o: 对于 Others 修改 a: (all) 对于所有人修改 [怎么修改] +, -, =: 作用的形式, 加上, 减掉, 等于某些权限 r, w, x 或者多个权限的组合, 比如 rx [哪个文件] 施加操作的文件, 可以为多个文件 除了上面这些修改形式, 还有一些简化版的形式, 就是用数字来表示相应的权限，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。 文件默认权限 文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。 目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。 一个使用Python的技巧我不怎么用权限这东西, 但是我却发现给 python 文件添加权限x 还算有用的. 为什么这么说? 因为通常, 如果一个 .py 没有x 权限, 在 terminal 中你就需要这样执行: 1~/Documents/Folder1$ python3 p1.py 如果你有了 x (可执行权限), 你运行这个文件可以直接这样打: 1~/Documents/Folder1$ ./p1.py 很酷炫有木有？但是上面这个脚本能够成功运行有一个前提，那就是你在这个Python脚本p1.py的开头加上一句话，如下所示： 12#!/usr/bin/python3print("Hello World") 好了，加上上面这句话的话以后运行这个脚本就可以直接用那本很酷炫的方式而不用每次都python3 xx.py啦。]]></content>
      <categories>
        <category>Linux操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2018%2F04%2F26%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[作为一名程序员，相信大家对Linux操作系统都不会陌生。但是Linux系统那些繁杂的操作命令通常让我们很头疼，我也在网上查阅了很多资料，做了一些总结。这里将常用的一些Linux操作命令(主要是与文件相关的操作命令)整理如下： sudo这个SuperUserDo(简写成”sudo”)是Linux新手要使用的最重要的命令。需要根权限的每一个命令都需要这个sudo命令。你可以在需要根权限的每个命令之前使用sudo 1$ sudo su pwd12~/Documents$ pwd# 获取当前所在的路径(绝对路径) ls(list)借助ls(list)命令，终端就会显示你正在处理的那个目录里面的所有文件和文件夹。假设我在Home目录(也就是”~”)里面，想查看当前目录下的文件夹和文件。相应的命令如下图所示： 12~$ ls# 显示当前目录的所有文件和文件夹 上面是ls命令最基本的使用方式，下面我们再看看ls命令其他的使用方式。 12~$ ls -l# 输出详细信息 -l (long 的简写). 这个指令会打印出文件的权限 (-rw-rw-r-- 之后我们在细说这个), 用户名, 文件大小, 修改日期, 文件名 12~$ ls -a# -a (all 的简写) 显示所有文件 . 这里还会显示隐藏的文件 (以 . 开头的) 12~$ ls -lh# -lh (human), 直接 -l 不方便人看, 这个指令是为了方便给人观看的. 注意这里的文件大小使用了 K, MB, GB 之类概括 12~$ ls --help# 还有很多其他的功能, 我们可以通过 --help 来查看 cd更改目录(cd)是始终在终端中使用的主要命令。它是最基本的Linux命令之一。使用这个命令很简单。只要输入你想要从当前目录进入到的那个文件夹的名称(如果是多层，中间用”/“进行分隔)。如果想要返回上一级，只要将双圆点(..)作为参数。 假设我在Home目录(也就是”~”)中，想进入到在Home目录里面的Documents子目录。下面是我可以使用cd命令的方法： 12~$ cd Documents/# 跳转到对应的Documents目录 若果要想返回到上一级目录，只用将双圆点(..)作为相应的参数即可。如下图所示： 12~/Documents$ cd ..# 返回上一级目录 除了上面两个基本的命令之外，还有一些有趣的，我们来看看。 12~$ cd Documents/Folder1/# 去往子文件夹Folder1 12~/Documents/Folder1$ cd -# 返回你刚刚所在的目录(也就是你的上一条命令所在的目录) 12~/Documents/Folder1$ cd ../../# 向上返回两次(再往上返回可以依次类推) 12~/Documents/Folder1$ cd ~# 去往Home touchtouch 命令的意思的新建，它的使用很简单。我们先去往 Documents 的文件夹, 里面已经有了 folder1 和 file1, 如果我们想新建一个 file2 使用下面的语句就好(可以指定文件的扩展名)。一个空文件就这样建立好了。 12~/Documents$ touch file2.txt# 建立一个文件名为file2的空的文本文档 如果你想同时建立多个文件，输入多个文件的名字，以空格分开。 12~/Documents$ touch file3.txt file4.txt file5.txt# 同时建立三个空的文本文档(也可以不指定文件的扩展名) cp拷贝粘贴是我们为了组织整理文件而需要完成的重要任务。使用cp将帮助你从终端拷贝粘贴文件。首先，你确定想要拷贝的那个文件，然后输入目的地位置，即可粘贴文件。cp (copy) 是复制文件或者文件夹的指令, 常用的方式是复制 “老文件” 到 “新文件”。即： 1~$ cp 老文件 新文件 注意: 如果你将文件拷贝到任何新文件都需要根权限的目录，那么你就需要使用sudo命令。 下面是cp命令的一些常见操作。 12~/Documents$ cp file1 file1copy# 将file1复制成file1copy 123~/Documents$ cp -i file1 file1copy# -i (interactive) 注意: 如果 file1copy 已经存在, 它将会直接覆盖已存在的 file1copy, 如果要避免直接覆盖, 我们在 cp 后面加一个选项。# 在这句问句后面打上 “Yes”, “Y”, 或者任何大小写形式的 “y” 和 “yes”, 它将进行覆盖操作. 直接回车或者打其他字母, 就会放弃复制这项操作。 12~/Documents$ cp file1 Folder1/# 将file1复制到文件夹Folder1 12~/Documents$ cp -R Folder1/ Folder2/# 复制文件夹, 需要加上 -R (recursive) 12~/Documents$ cp file* Folder1/# 复制多个文件。复制名字部分相同的多个文件到某个文件夹, * 是说"你就找文件名前面是 file 的文件, 后面是什么名字无所谓" 12~/Documents$ cp file2.txt file5.txt Folder1/# 或者你可以单独选定几个文件, cp 会默认最后一个选项是要复制去的文件夹. 比如把 file2.txt 和 file5.txt 复制去 Folder1/ mv知道了 cp, mv就好理解多了, 基本是一样的。mv是剪切(移动)的命令。下面是mv命令的一些常见操作。 12~/Documents$ mv file1 Folder1/# 将file1移动到文件夹Folder1 12~/Documents$ mv file1 file1rename# 重命名文件file1为file1rename。因为移动文件到原始的地点, 但是以不同的文件名。所以这种做法不就是在重命名嘛! 12~/Documents$ mv -f file1 Folder2/# 将文件file1强制移动到Folder2文件夹下。如果目标文件已经存在，不会询问而会直接覆盖。 最后还是想要提一句, 如果想要查看使用说明, 直接在指令后面打上 --help就能查看. mkdir仅仅会更改目录还不全面。有时候，你想要创建一个新的文件夹或子文件夹。可以使用mkdir命令来做到这一点。只要在终端中将你的文件夹名称放在mkdir命令的后面即可。mkdir (make directory) 就是创建一个文件夹的意思, 使用起来很简单。 以下是mkdir命令的一些常见操作。 12~/Documents$ mkdir Folder2/# 在Documents文件夹下创建一个文件夹Folder2 12~/Documents$ mkdir Folder2/folder# 在文件夹Folder2里面再创建一个子文件夹folder rmdirrmdir(remove directory) 也就是字面的意思，即移除文件夹。不过这有一个前提条件. 这些要移除的文件夹必须是空的，不然会失败。所以如果想刚刚建立的那个 Folder2 就不能被移除, 因为里面有个 folder 文件夹。那么怎么移除有文件的文件夹呢？这里需要用到我们后面讲的rm命令。 要移除个空文件夹, 比如我在新建一个 Folder3, 然后移除。 12~/Documents$ rmdir Folder3# 删除文件夹Folder3(rmdir只能移除空文件夹！！！) rmrm这个命令可以移除你的文件，甚至移除你的目录。如果文件需要根权限才能移除，可以使用-f。你还可以使用-r来进行递归移除，从而移除你的文件夹。 注意: 执行了 rm以后是不能进行返回操作的, 请确保别执行像这样的操作 rm /，这会清空你的电脑。 12~/Documents$ rm file1# 删除单个文件filer1 12345~/Documents$ rm -i file2# -i 或 -I 有提示地移除文件 (为了避免误删)# -i 会每个要移除的文件都进行提示~/Documents$ rm -i file2 fil3 file4 file5# -I 超过3个文件才进行提示 123~/Documents$ rm -r Folder1/# -r 或 -R (recursively) 用来删文件夹# 和 rmdir 不同, rm -r 可以在文件夹中有文件的情况下删除这个文件夹. 比如我的 Folder1 里有 file1 和 file2 两个文件. rm命令其他的特点和cp命令差不多，比如用带相应的前缀或者后缀(或者不带，这样会清空当前文件夹下所有文件)加’*’来一次性删除多个文件。 nanonano是 linux 的一款文字编辑工具. 我们可以拿它来做最基本的 terminal 端的文本编辑, 甚至可以写代码。下面我们用 touch 创建一个 Python 脚本。如果大家不懂Python 也没关系，你就知道我们可以拿 nano来编辑文字或者脚本就好了。 12~/Documents$ touch p1.py# 在Documents目录下创建一个python文件 然后用 nano 执行这个 p1.py 文件，如下图所示： 12~/Documents$ nano p1.py# 用nano命令执行这个文件 它就会变成一个文本编辑器, 你在里面可以写上一些脚本。然后按 “Ctrl + x” 来保存和退出。如果提示你保存, 你就按一下 “y” 键, 然后回车, 你的文件就被保存下来了。 接着如果你在 terminal 中输入相关的执行python文件的命令，你就能看到 terminal 执行了你的 python 文件。 cat作为用户，你常常需要查看来自脚本的一些文档或代码。同样，其中一个Linux基本命令是cat命令。它会为你显示文件里面的文本。 cat(catenate) 可以用来显示文件内容, 或者是将某个文件里的内容写入到其他文件里。详细的操作见下面。 123~/Documents$ cat p1.py &gt; p2.py~/Documents$ cat p2.py# &gt; 将文件的内容放到另一个文件里，这里我们将p1.py的内容写入到p2.py里面。 1234~/Documents$ cat p1.py p2.py &gt; p3.py~/Documents$ cat p3.py# &gt; 将多个文件的内容打包一起放入另一个文件，这里我们将p1.py的内容和p1.py的内容一同写入到p2.py里面。# 在显示的时候，两个文件的内容会分开显示 123~/Documents$ cat p2.py &gt;&gt; p3.py~/Documents$ cat p3.py# &gt;&gt; 将内容添加在一个文件末尾，这里我们将p2.py的内容添加到p3.py的末尾。 head1234~/Documents$ head -n 5 p2.py# 查看文件的前几行(默认查看前10行)# head [-n number] filename# -n ：后面接数字，代表显示几行的意思 tail1234~/Documents$ tail -n 6 p3.py# 查看文件的后几行(默认查看倒数后10行)# tail [-n number] filename# -n ：后面接数字，代表显示几行的意思 apt-get就不同的发行版而言，这个命令各不相同。在基于Debian的Linux发行版中，想安装、移除和升级任何软件包，我们可以使用高级包装工具(APT)软件包管理器。apt-get命令可帮助你安装需要在Linux中运行的软件。这是个功能强大的命令行工具，可以执行安装、升级、甚至移除软件这类任务。 在其他发行版(比如Fedora和Centos)中，有不同的软件包管理器。Fedora过去有yum，但现在它有dnf。 1~ sudo apt-get update 1~ sudo dnf update 12~ sudo apt-get install &lt;package name&gt;# 安装相应的软件或工具 grep你需要找到一个文件，但是又记不得它的确切位置或路径。grep可以帮助你解决这个问题。你可以使用grep命令，根据给定的关键字帮助找到文件。 grep是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 1234567$ grep [-acinv] [--color=auto] 搜寻字符串 filename# -a ： 将 binary 文件以 text 文件的方式进行搜寻# -c ： 计算找到个数# -i ： 忽略大小写# -n ： 输出行号# -v ： 反向选择，亦即显示出 没有搜寻字符串内容 的那一行# --color=auto ：找到的关键字加颜色显示 12~/Documents$ grep hello p1.python# 在p1.py文件中搜索"hello"这个单词 范例：把含有 the 字符串的行提取出来(注意默认会有 –color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串) 1234567$ grep -n 'the' regular_express.txt# 以下为相应的显示结果# 8:I can't finish the test.# 12:the symbol '*' is represented as start.# 15:You are the best is mean you are the no. 1.# 16:The world Happy is the same with "glad".#18:google is the best tools for search keyword 因为 { 和 }在 shell 是有特殊意义的，因此必须要使用转义字符进行转义。 1$ grep -n 'go\&#123;2,5\&#125;g' regular_express.txt grep还有很多更强大的用法，后续会继续更新。当然，具体的用法可以通过grep --help进行查看。 poweroff有时候，你需要直接从终端来进行关机。这个命令就能完成这项任务，别忘了在命令的开头添加sudo，因为它需要根权限才能执行poweroff。 1~$ sudo poweroff 结束语好了，基本的Linux命令大概就这么多。它会帮助你在这个早期阶段开始使用Linux，借助这些基本的Linux命令，开始使用Linux，并且定个目标：每天学会使用1个至3个命令。后续我也会继续更新~]]></content>
      <categories>
        <category>Linux操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令整理]]></title>
    <url>%2F2018%2F04%2F24%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言碎碎念自从使用Git作为版本控制工具以来，通过教程学习、手册查阅方式了解了Git的相关原理和Git的命令，能够顺利使用。但由于还不熟练，实践经验也还不够丰富，每次遇到问题都需要重新搜索，多次下来十分麻烦。另一方面，查阅手册往往是不够的，因为手册只会告诉你什么命令做什么用，不会根据不同场景告诉你应该用什么命令。 所以在这篇文章中，我将常用的Git命令根据不同的使用场景做一个整理，加深印象的同时也方便自己日后进行查阅。 四个概念这里借用阮一峰老师的文章《常用Git命令清单》中的图。 几个专有名词的译名如下： Workspace: 工作区，也就是正在编辑的文件目录 Index / Stage: 暂存区 Repository: 本地仓库，.git文件夹管理的版本库 Remote: 远程仓库，也就是github.com上面的仓库 例如，在最常用的命令串中： 12345678$ git add &lt;file&gt;#添加工作区指定文件的改动到暂存区，"&lt;file&gt;"为"."时添加全部文件$ git commit -m "XXXX"#提交暂存区的所有内容到本地仓库的当前分支$ git push -u origin master#上传本地仓库到已关联的远程仓库 建立工程在工作目录中建立与远程仓库关联的Git工程主要有两种情况：第一种是由本地上传到远程仓库；第二种是从远程仓库克隆到本地。 本地上传在这种情况下，远程仓库应该是没有工程的。在本地工程文件夹下： 123456789101112$ git init#初始化一个Git仓库，此时当前目录会增加一个.git文件夹(此文件夹默认是隐藏的)，当前文件夹受到Git的管理，并默认创建master分支$ git add &lt;file&gt;#添加指定文件到暂存区，"&lt;file&gt;"为"."时表明添加当前目录的所有文件到暂存区$ git commit -m "XXXX"#提交暂存区的所有内容到本地仓库的当前分支$ git remote add origin &lt;url&gt;#为当前项目添加远程主机。#其中origin为自定义的远程主机名，url为远程主机的地址（推荐采用ssh协议） 此时已经建立了本地仓库与远程仓库的关联，可以通过git push推送上传。第一次推送采用： 12$ git push -u origin master#将本地master分支推送到远程同名分支（若不存在则新建），同时-u指定origin为默认主机名，之后若要上传到origin可省略它。 远程克隆这种情况下，远程仓库已经有工程，只需要在本地工程文件夹下用git clone命令克隆： 1$ git clone &lt;url&gt; 此时本地仓库已经与对应远程仓库建立关联，为主机名origin的地址。 克隆其他分支git clone命令默认克隆远程项目的master分支及其历史，若还需克隆别的分支，可通过以下方式进行（以克隆dev分支为例）： 12$ git checkout -b dev origin/dev#检出origin下的dev分支到本地新建的dev分支，并建立本地分支与远程分支的追踪关系 或者： 12345678$ git checkout -b dev#新建并切换到本地分支dev$ git branch --set-upstream-to=origin/dev dev#建立origin/dev远程分支和dev本地分支的追踪关系$ git pull#拉取本地分支dev对应的远程分支的最新状态 托管到新的远程仓库在克隆需要的内容后，有时会希望托管到新的远程仓库。此时可以增加新的远程主机名: 1$ git remote add &lt;new_remote_name&gt; &lt;url&gt; 或者干脆更改原来origin的地址： 1$ git remote origin set-url &lt;url&gt; 分支管理查看分支12345678$ git branch#查看本地分支$ git branch -r#查看远程分支$ git branch -a#查看所有本地分支和远程分支 新建本地分支新建分支（不切换）： 1$ git branch &lt;new_branch&gt; 新建分支并切换到新分支： 1234$ git checkout -b &lt;new_branch&gt;#相当于：$ git branch &lt;new_branch&gt;$ git checkout &lt;new_branch&gt; 删除本地分支12345$ git branch -d &lt;branch&gt;#删除分支前检查该分支是否有未提交或者未合并的内容$ git branch -D &lt;branch&gt;#强制删除该分支 新建远程分支相当于把远程未添加的本地分支push到远程： 12$ git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;#建议远程与本地分支同名，同名时可省略远程分支名 删除远程分支相当于push一个本地的空分支： 12$ git push origin :&lt;remote_branch&gt;#本地分支为空 或者用--delete： 1$ git push origin --delete &lt;remote_branch&gt; 合并分支12345$ git merge &lt;branch&gt;#快进合并（指针指向改变），合并&lt;branch&gt;到当前分支$ git merge --no-ff &lt;branch&gt;#合并&lt;branch&gt;到当前分支，在当前分支生成新节点，保证每个分支的独立演变史 撤销与版本回退撤销工作区修改有时修改工作区后，发现修改错误，希望回到原来未修改时（上一次提交或暂存）的状态。可以采用git checkout命令： 1234567$ git diff#查看工作区未提交（或为暂存）的文件的具体修改$ git checkout -- &lt;file&gt;#恢复工作区指定文件到上一次提交（或暂存）状态$ git checkout .#撤销所有工作区修改 撤销暂存12$ git reset HEAD &lt;file&gt;#将指定文件撤出暂存区 版本回退希望将版本库回退到之前的提交时，采用git reset命令： 12345678$ git log#查看之前的版本提交记录$ git reset HEAD^#回退到上一个提交版本，^^代表上两个版本，以此类推。（也可以用~2等代替）或$ git reset &lt;commitID&gt;#commitID可由git log查看得到 有必要整理一下git reset命令的三个参数： 123456789$ git reset --soft HEAD^#重置版本库头指针，且将这次提交之后的所有变更移动到暂存区$ git reset --mixed HEAD^#默认参数，等同于 git reset HEAD^#重置版本库头指针和暂存区，即这次提交之后的所有更改都留在工作区$ git reset --hard HEAD^#重置版本库头指针、暂存区和工作区，即这次提交之后的所有更改都不在存在于当前状态 在没有将之后的提交推送到远程仓库的情况下，git reset --hard是个很危险的操作。若是已经推送到远程仓库，使用git pull可以重新获得之后的版本提交。若是在没有远程备份时使用--hard进行版本回退，又想恢复到之后的版本，在一定时间内（一般为30天）可以通过git reflog查看操作id，再使用git reset --hard &lt;ID&gt;恢复。 stash储藏有时手头的工作进行到一半，需要切换分支做一些其他事情，可以采用git stash命令将当前的工作区储藏起来。 12345678910111213$ git stash#储藏当前工作区$ git stash list#查看当前的stash储藏栈$ git stash apply#应用栈顶的储藏内容，恢复工作区到之前的储藏状态$ git stash apply stash@&#123;2&#125;#应用指定储藏内容$ git stash pop#与apply类似，但从栈中删除该储藏内容 多人协作推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： 12345#默认推送的为master主分支$ git push origin master#如果要推送其他分支，将该分支对应的名字来替换master即可$ git push origin dev 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： 12$ git branch* master 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： 12#注意：本地分支名称最好与远程分支保持一致。$ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程。 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你对同样的文件也做了修改，并且试图推送。 这个时候会推送失败,因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单: 先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。 1$ git pull 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令 1$ git branch --set-upstream branch-name origin/branch-name 最后再将你改好的分支push到远程仓库。这就是多人协作的工作模式，一旦熟悉了，就非常简单。 其他状态查看1$ git status 任何情况下都可以使用git status命令查看当前的版本控制状态（包括工作区、暂存区、仓库区），并给出当前状态下可能会用到的命令提示。经常使用该命令是好习惯。 查看远程库信息1$ git remote -v 配置git用户123$ git config user.name "your name"$ git config user.email "email@example.com"#配置当前目录的git用户，加上--config参数时配置这台机器的所有git仓库 协议更改有时版本克隆是采用的是https协议，以至于每一次提交都需要输入用户名密码，很麻烦。而使用ssh协议就会方便很多，需要将当前的仓库协议进行更换。事实上，重置远程仓库名为ssh协议地址就可以了。 1$ git remote origin set-url git@example.com....]]></content>
      <categories>
        <category>版本控制之Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何更改Github上面托管的项目的默认显示语言]]></title>
    <url>%2F2018%2F04%2F22%2F%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9Github%E4%B8%8A%E9%9D%A2%E6%89%98%E7%AE%A1%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%BB%98%E8%AE%A4%E6%98%BE%E7%A4%BA%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[最近将自己一门课的课程大作业，也算是一个小项目demo，放到了GitHub上面，由于项目里面包含许多下载的html文件，导致html代码远远的超过自己写的python代码，于是GitHub默认也就显示是html。 这种对于我这种有强迫症的人来说，简直就是不能忍受的。于是我就各种上网找解决方案。终于，在不懈的努力之后，让我给找到了，在这里分享给大家。 导致这种情况的主要原因是GitHub是使用Linguist来检测你的项目所使用的语言，Linguist具体的作用我个人猜测应该就是：统计你这个项目里面哪一种语言的代码量最多，就把这种语言作为当前这个项目的主语言,也就是默认显示语言。这种做法显然是很不合理的，你比如像python这种支持函数式编程而且崇尚语法简洁优雅的解释型脚本语言，它的代码量远远比不过其他的编译型语言(比如C/C++/Java)。 那么到底如何来解决这个问题呢？解决办法如下： 使用.gitattributes配置文件 具体做法是这样的：在你的GitHub代码仓库的根目录界面新建一个.gitattributes配置文件，如下图所示： 然后打开这个文件：把默认的显示语言（也就是统计的代码量最多的语言）全部改成你这个项目本来的语言。例如： 123*.js linguist-language=Python *.css linguist-language=Python *.html linguist-language=Python 这几行代码的意思就是说：将以.js , .css , .html 为扩展名的文件都按照Python语言来统计。就是这么简单。这么直接！！！ 好了，改完这些之后保存，再回到GitHub主界面就会看到默认的展示语言已经变成python了。主要的步骤就是这样，希望能够帮助到大家。]]></content>
      <categories>
        <category>版本控制之Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于惠普暗影精灵2 pro用一段时间之后，插上电源充不了电的问题]]></title>
    <url>%2F2018%2F04%2F22%2F%E5%85%B3%E4%BA%8E%E6%83%A0%E6%99%AE%E6%9A%97%E5%BD%B1%E7%B2%BE%E7%81%B52-pro%E7%94%A8%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%8F%92%E4%B8%8A%E7%94%B5%E6%BA%90%E5%85%85%E4%B8%8D%E4%BA%86%E7%94%B5%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[去年5月份换的新电脑，用到现在大半年了。近几天来突然发现电脑插上电源充不了电，关机重启啥的都没有效果，于是尝试着上网找各种解决方案，终于，在试了N种解决方案之后，终于让我成功地找到了解决问题的办法。现在将我的解决方案分享出来，希望对大家有所帮助。 具体的操作步骤（仅针对惠普电脑，其他品牌的电脑不敢保证，不过个人觉得应该差不多）如下： 先将电脑关机； 在关机状态下按住键盘上的windows和V键； 再按住上面的两个键的同时，不松开，再按住电源键，三个键同时按住不放2-3秒钟； 松开全部的按键； 按电源键开机，看是否会进入一个Bios设置界面，即是否会提示502，如果提示的话则表示操作成功； 再重新启动电脑一次，问题即可解决。]]></content>
      <categories>
        <category>电脑技巧</category>
      </categories>
      <tags>
        <tag>Computer Tricks</tag>
      </tags>
  </entry>
</search>
