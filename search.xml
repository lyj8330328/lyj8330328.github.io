<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SSM-CRUD]]></title>
    <url>%2F2018%2F07%2F20%2FSSM%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[一、SSM整合Spring+SpringMVC+Mybatis的整合思路：- 创建Maven项目- 导入相关依赖- 配置web.xml- 配置Spring- 配置Spring MVC- 配置Mybatis- 应用：使用连接池、分页、CRUD、事务管理、JSON返回数据 二、项目结构（使用IDEA） 三、搭建过程1.使用IDEA创建maven工程，然后导入以下依赖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243&lt;properties&gt; &lt;spring.version&gt;4.1.3.RELEASE&lt;/spring.version&gt; &lt;pagehelper.version&gt;4.1.6&lt;/pagehelper.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.spring.version&gt;1.3.2&lt;/mybatis.spring.version&gt; &lt;mybatis.version&gt;3.4.1&lt;/mybatis.version&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;jsqlparser.version&gt;1.0&lt;/jsqlparser.version&gt; &lt;jackson.version&gt;1.2.7&lt;/jackson.version&gt; &lt;servlet-api.version&gt;3.1.0&lt;/servlet-api.version&gt; &lt;druid.version&gt;1.0.18&lt;/druid.version&gt; &lt;log4j.version&gt;1.2.16&lt;/log4j.version&gt; &lt;commons-logging.version&gt;1.2&lt;/commons-logging.version&gt; &lt;commons-fileupload.version&gt;1.2.1&lt;/commons-fileupload.version&gt; &lt;commons-io.version&gt;1.3.2&lt;/commons-io.version&gt; &lt;commons-lang.version&gt;2.6&lt;/commons-lang.version&gt; &lt;aopalliance.version&gt;1.0&lt;/aopalliance.version&gt; &lt;mybatis-generator.version&gt;1.3.5&lt;/mybatis-generator.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSP相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;$&#123;jstl.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;servlet-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- pageHelper --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;$&#123;pagehelper.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--jsqlparser --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;$&#123;jsqlparser.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-logging.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-fileupload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-io.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-lang.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;$&#123;aopalliance.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-generator.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;!-- 资源文件拷贝插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- java编译插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!-- 配置Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.tld&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 2.配置web.xml- 配置Spring的IOC容器1234567&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;- 配置Spring MVC的核心控制器1234567891011121314&lt;servlet&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- spring mvc的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;将不同功能的配置文件分开，所以在这里引入了两个外部的xml文件applicationContext.xml和springMVC.xml，它们是对Spring和Spring MVC进行具体配置。- 过滤器的设置 - 编码方式（配置在所有过滤器前） 123456789101112 &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; - RESTful风格（在应用部分，进行CRUD操作时使用rest的风格，需要配置HiddenHttpMethodFilter） 12345678 &lt;filter&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 3.配置Spring（applicationContext.xml）- 配置自动扫描包包含Controller和ControllerAdvice注解的bean交给SpringMVC来扫描，Spring就不再扫描了，所以要把这两个注解排除在外。1234567&lt;context:component-scan base-package="com.li"&gt; &lt;!-- 去除由Springmvc负责扫描的注解 --&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.web.bind.annotation.ControllerAdvice" /&gt;&lt;/context:component-scan&gt;- 数据库配置文件（db.properties）1234jdbc.username=rootjdbc.password=123456jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc\:mysql\://127.0.0.1\:3306/sh?characterEncoding\=UTF-8&amp;useSSL\=false并且在Spring中加载此资源文件12345678&lt;bean id="propertyPlaceHolderConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:db.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;- 配置DataSource(二选一) - 普通的jdbc连接数据库 123456 &lt;bean class="org.springframework.jdbc.datasource.DriverManagerDataSource" id="dataSource"&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; - 使用连接池连接数据库(Druid) 12345678910111213141516171819202122232425262728293031 &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;!-- 基本属性 --&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name="initialSize" value="3" /&gt; &lt;property name="minIdle" value="3" /&gt; &lt;property name="maxActive" value="20" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="60000" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="60000" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="300000" /&gt; &lt;property name="validationQuery" value="SELECT 1" /&gt; &lt;property name="testWhileIdle" value="true" /&gt; &lt;property name="testOnBorrow" value="false" /&gt; &lt;property name="testOnReturn" value="false" /&gt; &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt; &lt;property name="poolPreparedStatements" value="true" /&gt; &lt;property name="maxPoolPreparedStatementPerConnectionSize" value="20" /&gt;&lt;/bean&gt; 4.配置Mybatis（继续在Spring中配置）- 配置SqlSession：配置对应的pojo，引用已经配好的数据源，因为在应用中有分页操作，所以同时配置第三方插件PageHelper。1234567891011121314151617181920212223&lt;bean id="sqlSession" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 自动扫描com.li.pojo下的类型 --&gt; &lt;property name="typeAliasesPackage" value="com.li.pojo"&gt;&lt;/property&gt; &lt;!-- 配置数据源 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 配置PageHelper --&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="properties"&gt; &lt;value&gt; helperDialect=mysql reasonable=true supportMethodsArguments=true params=count=countSql autoRuntimeDialect=true &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt;- 配置Mapper：Demo中使用Mybatis的注解方式进行映射，没有单独的xml映射文件，所以直接扫描mapper下的类即可。1234567891011121314151617181920&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.li.mapper"&gt;&lt;/property&gt;&lt;/bean&gt;``` &lt;/font&gt; ## 5.配置Spring mvc(springMVC.xml) &lt;font size="4"&gt; - 配置自动扫描包 在context:component-scan可以添加use-default-filters，spring配置中的use-default-filters用来指示是否自动扫描带有@Component、@Repository、@Service和@Controller的类。默认为true，即默认扫描。```bash&lt;context:component-scan base-package="com.li" use-default-filters="false"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt; &lt;context:include-filter type="annotation" expression="org.springframework.web.bind.annotation.ControllerAdvice" /&gt;&lt;/context:component-scan&gt;- 配置视图解析器12345&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView" /&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;&lt;/bean&gt;- 配置加载静态资源（访问html,css,js,images等）1&lt;mvc:default-servlet-handler /&gt;- 配置注解驱动（访问路径与方法匹配）虽然在web.xml中已经提供了过滤器进行SSM的中文处理，但是json处理还要加点额外的内容,具体如下所示：1234567&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults="true"&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes" value="text/plain;charset=UTF-8" /&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 6.日志文件配置（log4j.properties）12345678# Global logging configurationlog4j.rootLogger=ERROR, stdout# MyBatis logging configuration...log4j.logger.com.how2java=TRACE# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 7.pojo（Category.java）1234567891011121314151617181920212223package com.li.pojo;public class Category &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 8.mapper（CategoryMapper.java）1234567891011121314151617181920212223242526package com.li.mapper;import com.li.pojo.Category;import org.apache.ibatis.annotations.*;import org.springframework.stereotype.Repository;import java.util.List;@Mapperpublic interface CategoryMapper &#123; @Insert("insert into category(name) values (#&#123;name&#125;)") void add(Category category); @Delete("delete from category where id= #&#123;id&#125;") void delete(int id); @Select("select * from category where id= #&#123;id&#125;") Category get(int id); @Update("update category set name=#&#123;name&#125; where id=#&#123;id&#125;") void update(Category category); @Select("select * from category") List&lt;Category&gt; list();&#125; 9.service（CategoryService.java、CategoryServiceImpl.java）CategoryService.java123456789101112131415161718192021package com.li.service;import com.li.pojo.Category;import java.util.List;public interface CategoryService &#123; List&lt;Category&gt; list(); void add(Category category); void update(Category category); void delete(int id); Category get(int id); void addTwo();//用于测试事务&#125; CategoryServiceImpl.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.li.service.impl;import java.util.List;import com.li.mapper.CategoryMapper;import com.li.service.CategoryService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;import com.li.pojo.Category;@Servicepublic class CategoryServiceImpl implements CategoryService &#123; @Autowired CategoryMapper categoryMapper; public List&lt;Category&gt; list() &#123; // TODO Auto-generated method stub return categoryMapper.list(); &#125; @Override public void add(Category category) &#123; // TODO Auto-generated method stub categoryMapper.add(category); &#125; @Override public void update(Category category) &#123; // TODO Auto-generated method stub categoryMapper.update(category); &#125; @Override public void delete(int id) &#123; // TODO Auto-generated method stub categoryMapper.delete(id); &#125; @Override public Category get(int id) &#123; // TODO Auto-generated method stub return categoryMapper.get(id); &#125; @Override @Transactional(propagation = Propagation.REQUIRED, rollbackForClassName = "Exception") public void addTwo() &#123; // TODO Auto-generated method stub Category c1 = new Category(); c1.setName("短的名字"); categoryMapper.add(c1); Category c2 = new Category(); c2.setName("放不下放不下放不下放不下放不下放不下放不下放不下放不下放不下放不下放不下放不下放不下放不下放不下"); categoryMapper.add(c2); &#125;&#125; 10.controller（CategoryController.java）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.li.controller;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import com.li.pojo.Category;import com.li.service.CategoryService;@Controllerpublic class CategoryController &#123; @Autowired CategoryService categoryService; @RequestMapping(value = "/category", method = RequestMethod.GET) public String listCategory(Model model, @RequestParam(value = "start", defaultValue = "1") int start, @RequestParam(value = "size", defaultValue = "5") int size) &#123; PageHelper.startPage(start, size, "id desc"); List&lt;Category&gt; categories = categoryService.list(); PageInfo&lt;Category&gt; pageInfo = new PageInfo&lt;&gt;(categories); model.addAttribute("pageInfo", pageInfo); // categoryService.addTwo(); return "listCategory"; &#125; /** * 保存一条记录 * * @param category * @return */ @RequestMapping(value = "/category", method = RequestMethod.PUT) // @PutMapping("/category") public String saveCategory(Category category) &#123; categoryService.add(category); return "redirect:/category"; &#125; /** * 删除一条记录 * * @param category * @return */ // @DeleteMapping("/category/&#123;id&#125;") @RequestMapping(value = "/category/&#123;id&#125;", method = RequestMethod.DELETE) public String deleteCategory(Category category) &#123; categoryService.delete(category.getId()); return "redirect:/category"; &#125; /** * 更新一条记录 * * @param category * @param start * @return */ // @PostMapping("/category/&#123;id&#125;") @RequestMapping(value = "/category/&#123;id&#125;", method = RequestMethod.POST) public String updateCategory(Category category, int start) &#123; categoryService.update(category); return "redirect:/category?start=" + start; &#125; /** * 跳转到编辑页 * * @param model * @param id * @param start * @return */ // @GetMapping("/category/&#123;id&#125;") @RequestMapping(value = "/category/&#123;start&#125;/&#123;id&#125;", method = RequestMethod.GET) public String editCategory(Model model, @PathVariable("id") int id, @PathVariable("start") int start) &#123; Category category = categoryService.get(id); model.addAttribute("category", category); model.addAttribute("start", start); return "editCategory"; &#125; @RequestMapping("index") public String index() &#123; return "index"; &#125;&#125; 11.视图层（editCategory.jsp、listCategory.jsp）listCategory.jsp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt;&lt;head&gt;&lt;base href="&lt;%=basePath%&gt;"&gt;&lt;title&gt;My JSP 'listCategory.jsp' starting page&lt;/title&gt;&lt;meta http-equiv="pragma" content="no-cache"&gt;&lt;meta http-equiv="cache-control" content="no-cache"&gt;&lt;meta http-equiv="expires" content="0"&gt;&lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt;&lt;meta http-equiv="description" content="This is my page"&gt;&lt;!-- &lt;link rel="stylesheet" type="text/css" href="styles.css"&gt; --&gt;&lt;/head&gt;&lt;body&gt;&lt;div style="width:500px;margin:20px auto;text-align: center"&gt; &lt;table align='center' border='1' cellspacing='0'&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;编辑&lt;/th&gt; &lt;th&gt;删除&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;pageInfo.list&#125;" var="c" varStatus="st"&gt; &lt;tr&gt; &lt;td&gt;$&#123;c.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;c.name&#125;&lt;/td&gt; &lt;td&gt;&lt;a href="category/$&#123;pageInfo.pageNum &#125;/$&#123;c.id &#125;"&gt;编辑&lt;/a&gt;&lt;/td&gt; &lt;td&gt; &lt;form action="category/$&#123;c.id &#125;" method="post"&gt; &lt;input type="hidden" name="_method" value="DELETE"/&gt; &lt;button type="submit"&gt;删除&lt;/button&gt; &lt;/form&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;br/&gt; &lt;div style="text-align:center"&gt; &lt;a href="category?start=1"&gt;首 页&lt;/a&gt; &lt;a href="category?start=$&#123;pageInfo.pageNum-1&#125;"&gt;上一页&lt;/a&gt; &lt;a href="category?start=$&#123;pageInfo.pageNum+1&#125;"&gt;下一页&lt;/a&gt; &lt;a href="category?start=$&#123;pageInfo.pages&#125;"&gt;末 页&lt;/a&gt; &lt;/div&gt; &lt;form action="category" method="post"&gt; &lt;!--修改提交方式为PUT--&gt; &lt;input type="hidden" name="_method" value="PUT"/&gt; name:&lt;input name="name"/&gt;&lt;br/&gt; &lt;button type="submit"&gt;提交&lt;/button&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; editCategory.jsp12345678910111213141516171819202122232425262728293031323334&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;title&gt;My JSP 'editCategory.jsp' starting page&lt;/title&gt; &lt;meta http-equiv="pragma" content="no-cache"&gt; &lt;meta http-equiv="cache-control" content="no-cache"&gt; &lt;meta http-equiv="expires" content="0"&gt; &lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt; &lt;meta http-equiv="description" content="This is my page"&gt; &lt;!-- &lt;link rel="stylesheet" type="text/css" href="styles.css"&gt; --&gt; &lt;/head&gt; &lt;body&gt; &lt;div style="margin:0px auto; width:500px"&gt; &lt;form action="category/$&#123;category.id&#125;" method="post"&gt; name: &lt;input name="name" value="$&#123;category.name&#125;"&gt; &lt;br&gt; &lt;input name="start" value="$&#123;start &#125;" type="hidden"/&gt; &lt;button type="submit"&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 四、应用1.连接池Druid 连接池简介Druid首先是一个数据库连接池。Druid是目前最好的数据库连接池，在功能、性能、扩展性方面，都超过其他数据库连接池，包括DBCP、C3P0、BoneCP、Proxool、JBoss DataSource。Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。Druid是一个JDBC组件，它包括三个部分：- 基于Filter－Chain模式的插件体系。- DruidDataSource 高效可管理的数据库连接池。- SQLParserDruid的功能- 替换DBCP和C3P0。Druid提供了一个高效、功能强大、可扩展性好的数据库连接池。- 可以监控数据库访问性能，Druid内置提供了一个功能强大的StatFilter插件，能够详细统计SQL的执行性能，这对于线上分析数据库访问性能有帮助。- 数据库密码加密。直接把数据库密码写在配置文件中，这是不好的行为，容易导致安全问题。DruidDruiver和DruidDataSource都支持PasswordCallback。- SQL执行日志，Druid提供了不同的LogFilter，能够支持Common-Logging、Log4j和JdkLog，你可以按需要选择相应的LogFilter，监控你应用的数据库访问情况。- 扩展JDBC，如果你要对JDBC层有编程的需求，可以通过Druid提供的Filter机制，很方便编写JDBC层的扩展插件。 2.分页分页采用第三方插件PageHelper，在配置Mybatis的时候同时配置pagehelper插件。注：如果采用java方式配置，为什么不起作用？在springboot中就可以。 3.CRUD采用RESTful风格：增加PUT、删除DELETE、获取GET、修改POST## 4.事务设置Category中name字段为varchar(20)。在CategoryService中添加新方法——addTwo()，同时添加两个对象，一个名字在范围内，另一个超出20个字符的范围。如果不进行事务管理，那么其中名字合法的对象就会被插入，不合法的就不插入。如果进行事务管理，因为这两个操作发生在一个事务当中，当一个对象名字不合法，那么另一个对象也无法插入。- 进行事务配置修改applicationContext.xml，添加事务管理器和事务注解扫描器。12345&lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt;- 使用注解方式123456789101112@Override@Transactional(propagation = Propagation.REQUIRED, rollbackForClassName = "Exception")public void addTwo() &#123; // TODO Auto-generated method stub Category c1 = new Category(); c1.setName("短的名字"); categoryMapper.add(c1); Category c2 = new Category(); c2.setName("放不下放不下放不下放不下放不下放不下放不下放不下放不下放不下放不下放不下放不下放不下放不下放不下"); categoryMapper.add(c2);&#125;- 使用XML配置方式（支持AOP）123456789101112131415161718&lt;tx:advice id="txadvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="add*" propagation="REQUIRED" rollback-for="Exception" /&gt; &lt;tx:method name="del*" propagation="REQUIRED" rollback-for="Exception" /&gt; &lt;tx:method name="edit*" propagation="REQUIRED" rollback-for="Exception" /&gt; &lt;tx:method name="update*" propagation="REQUIRED" rollback-for="Exception" /&gt; &lt;tx:method name="list*" propagation="REQUIRED" rollback-for="Exception" /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt; &lt;aop:pointcut id="serviceMethod" expression="execution(* com.li.service.*.*(..))" /&gt; &lt;aop:advisor pointcut-ref="serviceMethod" advice-ref="txadvice" /&gt;&lt;/aop:config&gt;- 测试类12345678910111213141516171819202122package com.li.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.li.service.CategoryService;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class TestCategory &#123; @Autowired private CategoryService categoryService; @Test public void test() &#123; categoryService.addTwo(); &#125;&#125;- 测试结果 5.JSON- 新增CategoryJsonController.java用来返回JSON数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.li.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import com.alibaba.fastjson.JSONObject;import com.li.pojo.Category;import com.li.service.CategoryService;import java.util.List;@Controllerpublic class CategoryJsonController &#123; @Autowired private CategoryService categoryService; @ResponseBody @RequestMapping("/submitCategory") public String submitCategory(@RequestBody Category category) &#123; System.out.println("SSM接受到浏览器提交的json，并转换为Category对象:" + category); categoryService.add(category); return "ok"; &#125; @ResponseBody @RequestMapping("/getOneCategory/&#123;id&#125;") public String getOneCategory(@PathVariable("id") int id) &#123; Category c = categoryService.get(id); JSONObject json = new JSONObject(); json.put("category", JSONObject.toJSON(c)); return json.toJSONString(); &#125; @ResponseBody @RequestMapping("/getManyCategory") public String getManyCategory() &#123; List&lt;Category&gt; cs = categoryService.list(); return JSONObject.toJSON(cs).toString(); &#125;&#125;- 测试：因为无法访问静态资源（暂时没有解决），使用Postman来进行测试。 - 获取一条数据 - 获取全部数据 五、源码]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Redis的zSet集合做数据缓存实现分页查询]]></title>
    <url>%2F2018%2F07%2F20%2F%E5%9F%BA%E4%BA%8ERedis%E7%9A%84zSet%E9%9B%86%E5%90%88%E5%81%9A%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[一、Redis数据结构介绍 结构类型 结构存储的值 结构的读写能力 String 可以是字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作；对象和浮点数执行自增(increment)或者自减(decrement) List 一个链表，链表上的每个节点都包含了一个字符串 从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪(trim)；读取单个或者多个元素；根据值来查找或者移除元素 Set 包含字符串的无序收集器(unorderedcollection)，并且被包含的每个字符串都是独一无二的、各不相同 添加、获取、移除单个元素；检查一个元素是否存在于某个集合中；计算交集、并集、差集；从集合里卖弄随机获取元素 Hash 包含键值对的无序散列表 添加、获取、移除单个键值对；获取所有键值对 Zset 字符串成员(member)与浮点数分值(score)之间的有序映射，元素的排列顺序由分值的大小决定 添加、获取、删除单个元素；根据分值范围(range)或者成员来获取元素 二、需求分析1.场景描述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一开始分页是通过每次请求数据库获取数据，然后再交给视图显示。现在假设数据量庞大，每回都请求数据库的损耗比较大，所以通过Redis来进行查询优化。当第一次从数据库中请求到数据后，就把数据存储到Redis中，下次访问数据时先从缓存中查找，找不到的话再去数据库中查找。所以，当进行CRUD抽插数据库时，先对缓存进行抽插，然后再对数据库中的信息进行维护。 2.流程图 3.数据结构选择&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过比较不同数据结构的使用场景后，发现Zset结构正是我们想要的缓存类型。我们把分数score设置为Category的主键,value则存放序列化后的Category对象，redis的数据会根据socre自动排序，我们只需要对redis进行新增、删除的操作就行了（修改可以先删除再新增）。如何实现分页？将SET里面的集合根据Score进行排序（逆序），然后指定start和count，就可以实现分页查询了。 三、思路分析框架采用springboot，而且所有请求访问都是RESTful风格的。 1.分页数据查询（重点）：findAll(int start,int size)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体的分页查询策略如下：前提条件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要保存在Redis中的数据有：Category所有对象，分页数，最后一页中的数据条数。何时将这些对象放入Redis中呢?Category对象在用户首次访问页面的时候，将对应页面数据访问缓存中，随之分页数也存入缓存中。最后一页的数据条数在用户访问到末页的时候存入。 准备工作 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先获取缓存中的三个变量：count—缓存中的数据量，pages—分页数，lastPage—最后一页的数据量。然后在Redis中对ZSet进行查询，在这里进行正序和逆序两次查询。假如分页数为5，则逆序第1页的数据就对应正序第5页的数据，通过比较正序和逆序获取数据量的大小和内容，来判断当前访问页的数据是从数据库中获取还是从Redis中获取。 数据获取 IF正序和逆序查询到数据量都为0，说明用户第一次访问列表页，则从数据库中读取对应页面的数据并放入Redis中。 ELSE IF：首先判断当前页是否是最后一页。因为到达最后一页有不同的方法： IF：用户从首页依次点击下一页进入末页。那么此时判断缓存中的数据量是否与最后一页的页码*pages+lastPage是否相等，如果相等则从ZSet的逆序序列中获取最后一页数据。 ELSE：用户直接点击末页进入最后一页。那么就从正序序列中获取最后一页数据。 ELSE：从数据库中获取 ELSE：不是最后一页 IF：正序和逆序中放的数据一样，则从缓存中获取。 ELSE： IF：正序和逆序查询得到的数据刚好查一页 IF：逆向查询，正序序列中数据个数与lastPage相同，说明此页未加载到缓存中，需要从数据库中获取。 ELSE：否则从正序序列中获取缓存数据 ELSE IF：从正序序列中获取数据，需要进行逆置。 ELSE 从数据库中查询数据 注： 当前页面显示的数据有两种状态：一种是从数据库中获取得到的（第一次访问该页面），另一种是从Redis中获取的缓存数据。 当用户第一次访问页面的时候，用户需要显示哪一页，才会查询对应的页面数据，不会有多余的查询操作。第一次查询是从数据库中获取，然后把数据放入Redis中以便下次访问相同页面时直接从缓存中获取。 那么，如何判断用户是否是第一次访问？那就根据Redis缓存中是否有相应的数据，没有的话说明是第一次访问，就需要从数据库中获取。 场景分解： 当用户访问完第二页后，再点击上一页，那么上一页的数据就应该从Redis缓存中获取，因为在第一次从数据库中获取到数据后就把它存储到缓存当中了。所以通过判断当前redis中现有数据量和（请求页数x页长）的大小关系来判断是否可以从内存中获取数据。比如说现在请求第3页，那么缓存中必须至少有15条数据，否则还需从数据库中读取。但是也有例外，比如说最后一页的数据不满5条，那么（请求页数x页长）始终大于缓存中的数据量，所以在第一次从数据库中拉取最后一页数据的时候，就需要记录一下最后一页的数据条数，然后再增加一个判断条件，用来确定到底是从数据库中获取还是从缓存中获取。 获取缓存数据的方法： reverseRange(K,start,end)：键为K的集合，索引start&lt;=index&lt;=end的元素子集，倒序。下标从0开始，需要查找5条记录，那么start=0,end=4。一开始传入的start是1，所以需要自减一次。具体表达式如下所示：1operations.reverseRange("category",start*5,(start+1)*5-1); 因为使用MyBatis的第三方插件PageHelper进行分页，所以返回前端视图的是PageHelper的PageInfo对象。PageInfo对象里面就保存了分页的具体信息:分页的大小、分页数等。 执行逻辑（第一次访问）：访问第一页直接从数据库中拉取数据，在访问第二页的时候要判断数据库中是否已经有了对应的数据（场景：访问完第二页，返回第一页，再访问第二页就要从缓存中拉取）2.保存一条数据：save(Category category)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将新添加的数据先保存在缓存中，然后再存入到数据库中. 3.删除一条数据：delete(int id)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先判断在缓存中是否可以找到被删元素，可以找到的话就删除，然后再删除数据库中的数据。4.获取一条数据：get(int id)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先从缓存中查询数据，可以找到的话就返回，找不到就再去数据库中找。5.更新一条数据：update(Category category)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先更新缓存再更新数据库四、具体实现1.搭建springboot 用IDEA创建springboot项目，初始添加的依赖有：Web、Thymeleaf、MySql、JDBC、MyBatis、Redis等。 在application.properties中添加如下内容（配置redis和数据库）：12345678910111213141516171819202122232425262728#数据库配置spring.datasource.url=jdbc:mysql://127.0.0.1:3306/sh?characterEncoding=UTF-8&amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.jpa.properties.hibernate.hbm2ddl.auto=update#配置端口server.port=9090# Redis数据库索引（默认为0）spring.redis.database=0# Redis服务器地址spring.redis.host=localhost# Redis服务器连接端口spring.redis.port=6379# Redis服务器连接密码（默认为空）spring.redis.password=# 连接池最大连接数（使用负值表示没有限制）spring.redis.pool.max-active=8# 连接池最大阻塞等待时间（使用负值表示没有限制）spring.redis.pool.max-wait=-1# 连接池中的最大空闲连接spring.redis.pool.max-idle=8# 连接池中的最小空闲连接spring.redis.pool.min-idle=0# 连接超时时间（毫秒）spring.redis.timeout=0 2.建立数据库表 12345CREATE TABLE `category` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL DEFAULT '', PRIMARY KEY (`Id`)) ENGINE=InnoDB AUTO_INCREMENT=50 DEFAULT CHARSET=utf8; 3.建立Model层(Category类，用来映射数据库中的表) 12345678910111213141516171819package com.example.springbootmybatisredisdemo.pojo;import java.io.Serializable;public class Category implements Serializable &#123; private static final long serialVersionUID = -1L; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 4.建立BO层（Service和ServiceImpl）————负责具体业务操作 Service.java 1234567891011121314package com.example.springbootmybatisredisdemo.service;import com.example.springbootmybatisredisdemo.pojo.Category;import com.github.pagehelper.PageInfo;public interface Service &#123; PageInfo&lt;Category&gt; findAll(int start,int size); void save(Category category); void delete(int id); Category get(int id); void update(Category category);&#125; ServiceImpl.java，在这个实现类中，主要是完成对数据的CRUD。具体如下分析: 对数据库的抽插需要CategoryMapper类的对象，对Redis抽插需要RedisTemplate，如何获取这两个Bean? 采用自动装配的方式——@Autowired。12345@Autowiredprivate CategoryMapper categoryMapper;@Autowiredprivate RedisTemplate redisTemplate; 删除一条数据123456@Overridepublic void delete(int id) &#123; ZSetOperations operations=redisTemplate.opsForZSet(); operations.removeRangeByScore("category",id,id); categoryMapper.delete(id);&#125; 获取一条数据1234567891011121314151617@Overridepublic Category get(int id) &#123; ZSetOperations operations=redisTemplate.opsForZSet(); //缓存存在 Long hasKey=operations.size("category"); if(hasKey&gt;0)&#123; LOGGER.info("在缓存中查找"); Set&lt;Category&gt; categories=operations.rangeByScore("category",id,id); return categories.iterator().next(); &#125;else &#123; LOGGER.info("在数据库中查找"); Category category=categoryMapper.get(id); operations.add("category",category,category.getId()); return category; &#125;&#125; 更新一条数据1234567@Overridepublic void update(Category category) &#123; ZSetOperations operations=redisTemplate.opsForZSet(); operations.removeRangeByScore("category",category.getId(),category.getId()); operations.add("category",category,category.getId()); categoryMapper.update(category);&#125; 保存一条数据123456789@Overridepublic void save(Category category) &#123; ZSetOperations operations=redisTemplate.opsForZSet(); Set&lt;Category&gt; categories=operations.reverseRangeByScore("category",0,100,0,1); category.setId(categories.iterator().next().getId()+1); operations.add("category",category,categories.iterator().next().getId()+1); categoryMapper.save(category); //更新缓存&#125; 分页查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Overridepublic PageInfo&lt;Category&gt; findAll(int start,int size) &#123; ZSetOperations operations=redisTemplate.opsForZSet(); Long count=operations.size("category"); long page=count%5&gt;0?(count/5)+1:count/5; int end= (int) (count%5); Long pagesize=operations.size("page"); int pages=0; if(pagesize!=0) &#123; String real_page=operations.range("page",0,1).iterator().next().toString(); pages=Integer.parseInt(real_page); &#125; int lastPage=0; if(start&gt;pages&amp;&amp;pages!=0) --start; if(operations.size("lastPage")!=0) &#123; lastPage = Integer.parseInt(operations.range("lastPage", 0, 1).iterator().next().toString()); &#125; if(count&gt;=start*5||(count==(start-1)*5+lastPage&amp;&amp;count!=0))&#123; LOGGER.info("从缓存中查找"); LOGGER.info("count:"+count); LOGGER.info("start:"+start); LOGGER.info("page:"+page); LOGGER.info("pages:"+pages); if(start&gt;0) --start;//处理0页 else if(start*5&gt;count) --start;//处理最后一页+1 Set&lt;Category&gt; categories2=operations.reverseRange("category",start*5,(start+1)*5-1); if(categories2.iterator().hasNext())&#123; List&lt;Category&gt; categoryList=new ArrayList&lt;&gt;(); for(Category category:categories2)&#123; categoryList.add(category); &#125; PageInfo&lt;Category&gt; pageInfo2=new PageInfo&lt;&gt;(categoryList); pageInfo2.setPageNum(++start); LOGGER.info("当前页："+pageInfo2.getPageNum()); //pageInfo2.setPages(pages); return pageInfo2; &#125;else &#123; if(start+1==pages)&#123; LOGGER.info("最后一页"); lastPage(start,size); &#125; LOGGER.info("从数据库中查找1"); LOGGER.info("start:"+start); LOGGER.info("count:"+count); LOGGER.info("page:"+page); LOGGER.info("pages:"+pages); PageInfo&lt;Category&gt; pageInfo = db_select(start+1,size); return pageInfo; &#125; &#125;else &#123; LOGGER.info("从数据库中查找2"); LOGGER.info("start:"+start); LOGGER.info("count:"+count); LOGGER.info("page:"+page); LOGGER.info("pages:"+pages); PageInfo&lt;Category&gt; pageInfo = db_select(start++,size); return pageInfo; &#125;&#125; 5.建立DAO层（CategoryMapper类）————负责抽插数据库 12345678910111213141516171819202122232425262728package com.example.springbootmybatisredisdemo.mapper;import com.example.springbootmybatisredisdemo.pojo.Category;import org.apache.ibatis.annotations.*;import org.springframework.cache.annotation.CacheConfig;import org.springframework.stereotype.Repository;import java.util.List;@Repository@Mapperpublic interface CategoryMapper &#123; @Select("select * from category") List&lt;Category&gt; findAll(); @Insert("insert into category(name) values (#&#123;name&#125;)") int save(Category category); @Delete(" delete from category where id= #&#123;id&#125; ") void delete(int id); @Select("select * from category where id= #&#123;id&#125; ") Category get(int id); @Update("update category set name=#&#123;name&#125; where id=#&#123;id&#125; ") void update(Category category);&#125; 6.建立控制层Controller(CategoryController)————负责业务流程控制 12345678910111213141516171819202122232425262728package com.example.springbootmybatisredisdemo.mapper;import com.example.springbootmybatisredisdemo.pojo.Category;import org.apache.ibatis.annotations.*;import org.springframework.cache.annotation.CacheConfig;import org.springframework.stereotype.Repository;import java.util.List;@Repository@Mapperpublic interface CategoryMapper &#123; @Select("select * from category") List&lt;Category&gt; findAll(); @Insert("insert into category(name) values (#&#123;name&#125;)") int save(Category category); @Delete(" delete from category where id= #&#123;id&#125; ") void delete(int id); @Select("select * from category where id= #&#123;id&#125; ") Category get(int id); @Update("update category set name=#&#123;name&#125; where id=#&#123;id&#125; ") void update(Category category);&#125; 7.视图层View listCategories.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="showing"&gt; &lt;h2&gt;SpringBoot+Mybatis+Redis&lt;/h2&gt; &lt;div style="width:500px;margin:20px auto;text-align: center"&gt; &lt;table align="center" border="1" cellspacing="0"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;td&gt;编辑&lt;/td&gt; &lt;td&gt;删除&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each="c: $&#123;pageInfo.list&#125;"&gt; &lt;td align="center" th:text="$&#123;c.id&#125;"&gt;&lt;/td&gt; &lt;td align="center" th:text="$&#123;c.name&#125;"&gt;&lt;/td&gt; &lt;td align="center" &gt;&lt;a th:href="@&#123;/category/&#123;start&#125;/&#123;id&#125;(id=$&#123;c.id&#125;,start=$&#123;pageInfo.pageNum&#125;)&#125;"&gt;编辑&lt;/a&gt;&lt;/td&gt; &lt;td align="center" &gt; &lt;form th:action="@&#123;/category/&#123;id&#125;(id=$&#123;c.id&#125;)&#125;" action="/category" method="post"&gt; &lt;input type="hidden" name="_method" value="DELETE"/&gt; &lt;button type="submit"&gt;删除&lt;/button&gt; &lt;/form&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;br /&gt; &lt;div&gt; &lt;a th:href="@&#123;/category(start=1)&#125;"&gt;[首 页]&lt;/a&gt; &lt;a th:href="@&#123;/category(start=$&#123;pageInfo.pageNum -1&#125;)&#125;"&gt;[上一页]&lt;/a&gt; &lt;a th:href="@&#123;/category(start=$&#123;pageInfo.pageNum +1&#125;)&#125;"&gt;[下一页]&lt;/a&gt; &lt;a th:href="@&#123;/category(start=$&#123;pageInfo.pages&#125;)&#125;"&gt;[末 页]&lt;/a&gt; &lt;/div&gt; &lt;form action="/category" method="post"&gt; &lt;!--修改提交方式为PUT--&gt; &lt;input type="hidden" name="_method" value="PUT"/&gt; name:&lt;input name="name"/&gt;&lt;br/&gt; &lt;button type="submit"&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; editCategory.html 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="showing"&gt; &lt;h2&gt;SpringBoot+Mybatis&lt;/h2&gt; &lt;div style="margin:0px auto; width:500px"&gt; &lt;form th:action="@&#123;/category/&#123;id&#125;(id=$&#123;c.id&#125;)&#125;" method="post"&gt; name: &lt;input name="name" th:value="$&#123;c.name&#125;" /&gt; &lt;br/&gt; &lt;input name="id" type="hidden" th:value="$&#123;c.id&#125;" /&gt; &lt;input name="start" type="hidden" th:value="$&#123;start&#125;"/&gt; &lt;button type="submit"&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 8.第三方分页插件PageHelper和Redis的配置 PageHelperConfig.java 使用过mybatis的人都知道，mybatis本身就很小且简单，sql写在xml里，统一管理和优化。缺点当然也有，比如我们使用过程中，要使用到分页，如果用最原始的方式的话，1.查询分页数据，2.获取分页长度，也就是说要使用到两个方法才能完成分页。有没有更更好的分页方式的，pagehelper分页插件因此而诞生，他的原理是利用mybatis拦截器，在查询数据库的时候，拦截下SQL，然后进行修改，从而实现分页。123456789101112131415161718192021package com.example.springbootmybatisredisdemo.config;import com.github.pagehelper.PageHelper;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.Properties;@Configurationpublic class PageHelperConfig &#123; @Bean public PageHelper pageHelper()&#123; PageHelper pageHelper = new PageHelper(); Properties p = new Properties(); p.setProperty("offsetAsPageNum", "true"); p.setProperty("rowBoundsWithCount", "true"); p.setProperty("reasonable", "true"); pageHelper.setProperties(p); return pageHelper; &#125;&#125; RedisConfig.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.example.springbootmybatisredisdemo.config;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.beans.factory.annotation.Value;import org.springframework.cache.CacheManager;import org.springframework.cache.annotation.CachingConfigurerSupport;import org.springframework.cache.annotation.EnableCaching;import org.springframework.cache.interceptor.KeyGenerator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;@Configuration@EnableCaching //启用缓存public class RedisConfig&#123; @Value(value = "$&#123;spring.redis.host&#125;") private String host; @Value(value = "$&#123;spring.redis.port&#125;") private int port; @Value(value = "$&#123;spring.redis.timeout&#125;") private int timeout; //缓存管理器（将springboot自带的缓存替换成Redis） @Bean public CacheManager cacheManager(@SuppressWarnings("rawtypes")RedisTemplate redisTemplate)&#123; RedisCacheManager cacheManager=new RedisCacheManager(redisTemplate); cacheManager.setDefaultExpiration(10000); return cacheManager; &#125; @Bean public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory)&#123; StringRedisTemplate template = new StringRedisTemplate(factory); setSerializer(template);//设置序列化工具 template.afterPropertiesSet(); return template; &#125; private void setSerializer(StringRedisTemplate template)&#123; @SuppressWarnings(&#123; "rawtypes", "unchecked" &#125;) Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); template.setValueSerializer(jackson2JsonRedisSerializer); &#125;&#125; 五、测试]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github如何同步更新一个你Fork的仓库？]]></title>
    <url>%2F2018%2F06%2F12%2FGithub-%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AA%E4%BD%A0Fork%E7%9A%84%E4%BB%93%E5%BA%93%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[我们在进行Github协同开发的时候，往往会去fork一个仓库到自己的Github中，过一段时间以后，原仓库可能会有各种提交以及修改，很可惜，Github本身并没有自动进行同步的机制，这个需要我们手动去执行，现在我来演示一下如何进行自己的仓库和原仓库进行Gith同步的操作。重点在于：除了origin以外，增加一个upstream，来跟踪原仓库的更新。 先将你fork到自己的Github的远程仓库克隆到本地1$ git clone https://github.com/zmzhouXJTU/Problem-sets 查看远程仓库的信息123$ git remote -vorigin https://github.com/zmzhouXJTU/Problem-sets (fetch)origin https://github.com/zmzhouXJTU/Problem-sets (push) 配置原远程仓库(即你所fork的)的路径1$ git remote add upstream https://github.com/ACLoong/Problem-sets 再次查看远程仓库信息确定是否配置成功12345$ git remote -vorigin https://github.com/zmzhouXJTU/Problem-sets (fetch)origin https://github.com/zmzhouXJTU/Problem-sets (push)upstream https://github.com/ACLoong/Problem-sets (fetch)upstream https://github.com/ACLoong/Problem-sets (push) 抓取原仓库的更新文件，该文件会被存储在一个本地分支upstream/master上1234567$ git fetch upstreamremote: Counting objects: 21, done.remote: Compressing objects: 100% (15/15), done.remote: Total 21 (delta 4), reused 5 (delta 1), pack-reused 0Unpacking objects: 100% (21/21), done.From https://github.com/ACLoong/Problem-sets * [new branch] master -&gt; upstream/master 切换到本地主分支(如果当前不在的话)12$ git checkout master# Switched to branch 'master' 将原仓库的更新文件(即存储在本地的upstream/master分支上的文件)与本地仓库的当前分支合并123456$ git merge upstream/masterUpdating 60b537a..426148cFast-forward problem_set/first_week/refs/Process&amp;Thread.md | 29 +++++++++++++++++++++++++++ 1 file changed, 29 insertions(+) create mode 100644 problem_set/first_week/refs/Process&amp;Thread.md Note: 此时，你的本地仓库已经和原来仓库完全同步了。但是注意，此时只是你电脑上的本地仓库和原作者的远程github仓库同步了，你fork到自己的github远程仓库还没有同步。要想实现本地和自己的Github远程仓库的同步，只需要如下操作即可： 将其更新到自己的Github远程仓库，可以利用命令git push origin master来实现123456789$ git push origin masterCounting objects: 21, done.Delta compression using up to 4 threads.Compressing objects: 100% (16/16), done.Writing objects: 100% (21/21), 5.65 KiB | 1.88 MiB/s, done.Total 21 (delta 4), reused 0 (delta 0)remote: Resolving deltas: 100% (4/4), completed with 2 local objects.To https://github.com/zmzhouXJTU/Problem-sets 60b537a..426148c master -&gt; master 好了，至此任务就完成了。不知你是否看明白了呢？有任何问题，欢迎在此博客下方评论留言。]]></content>
      <categories>
        <category>版本控制之Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件权限]]></title>
    <url>%2F2018%2F04%2F26%2FLinux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[在 Linux 操作系统中，权限是一个非常重要的东西。 它无时无刻不在影响着你的各种操作。就像有的时候，你想去百度云下载一些别人分享的文件，可是你却发现虽然你能看到文件但是你却不能下载，这就是一种权限的典型例子。在 Linux 中, 这种权限随处可见。你可以设置，让别人不能越界。 不过像我这种人，也就是一台电脑， 一个用户(手动滑稽)，涉及不到多少有关权限方面的问题。 如果你也和我差不多，只有你自己在用 Linux 的电脑，主要用它来运行你的代码。我教你一招来修改权限，并且方便运行你的 Python 脚本的招数。 这里不会涉及过深的权限管理。我们了解一些基础，方便你拿你的 Linux 跑机器学习的代码就好。如果你想扩展学习的话, 网上会有很多教程。可以自行谷歌。 ls查看权限查看文件权限的方法很简单，其实在之前我的上一篇博文就讲了这个内容。 如果你还记得的话，我们在说 ls指令的时候, 提到过权限问题， 不过到了这节内容我们仔细的来说一说权限。如果你在 Terminal 中输入如下图片中的指令： 如上图所示，在 Terminal 中查看文件的权限的命令可以用ls -l 或者ls -lh，这个是看当前目录下面所有文件的权限，如果你只是想单独看看某一个具体的文件的权限，只需要在后面加上相应的文件名就可以了，比如ls -lh p1.py。 我们看到的上图中的-rw-rw-r--就是相关的权限啦。那么这些具体又是表达什么意思的呢？看下面的图就明白啦。 Type: 很多种 (最常见的是 - 为文件, d 为文件夹, 其他的还有l, n … 这种东西, 真正自己遇到了, 网上再搜就好, 一次性说太多记不住的)。 User: 后面跟着的三个空是使用 User 的身份能对这个做什么处理 (r 可读; w 可写; x 可执行; - 不能完成某个操作)。 Group: 一个 Group 里可能有一个或者多个 user, 这些权限的样式和 User 一样。 Others: 除了 User 和 Group 以外人的权限。 如果有人对 User, group, others 这三个没什么概念的话，我这里补充一下。User 一般就是指你，这个当前正在使用电脑的人。 Group 是一个 User 的集合，最开始创建新 User 的时候, 他也为这个 User 创建了一个和 User 一样名字的 Group, 这个新 Group 里只有这个 User。一般来说，像一个企业部门的电脑，都可以放在一个 Group 里, 分享了一些共享文件和权限。Others 就是除了上面提到的 User 和 Group 以外的人。 好了, 有了这些理解, 我们拿上面的 p1.py 来举例. 我们可以将 -rw-rw-r-- 拆成 - (这是文件), -rw(这个 User可以读,写), rw- (这个Group里可以读,写), r– (其他人只能读)。 chmod 修改权限好了, 我们知道了这些权限的问题, 那我们如何来改写权限呢? chmod (change mode)命令就是来干这个的。 通常的修改形式是： 1~$ chmod [谁] [怎么修改] [哪个文件] 举个最简单的例子, 现在的 p1.py 的权限是 -rw-rw-r--, 如果我们想让user和group拥有执行的能力。按照下面这样来改就行了。相应的结果如下图所示： 这里的 ug+x 很形象, User,Group + execute , 给 p1.py 这个文件进行修改。所以我们的修改形式就能总结出下面这样： [谁] u: 对于 User 修改 g: 对于 Group 修改 o: 对于 Others 修改 a: (all) 对于所有人修改 [怎么修改] +, -, =: 作用的形式, 加上, 减掉, 等于某些权限 r, w, x 或者多个权限的组合, 比如 rx [哪个文件] 施加操作的文件, 可以为多个文件 除了上面这些修改形式, 还有一些简化版的形式, 就是用数字来表示相应的权限，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。 文件默认权限 文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。 目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。 一个使用Python的技巧我不怎么用权限这东西, 但是我却发现给 python 文件添加权限x 还算有用的. 为什么这么说? 因为通常, 如果一个 .py 没有x 权限, 在 terminal 中你就需要这样执行: 1~/Documents/Folder1$ python3 p1.py 如果你有了 x (可执行权限), 你运行这个文件可以直接这样打: 1~/Documents/Folder1$ ./p1.py 很酷炫有木有？但是上面这个脚本能够成功运行有一个前提，那就是你在这个Python脚本p1.py的开头加上一句话，如下所示： 12#!/usr/bin/python3print("Hello World") 好了，加上上面这句话的话以后运行这个脚本就可以直接用那本很酷炫的方式而不用每次都python3 xx.py啦。]]></content>
      <categories>
        <category>Linux操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2018%2F04%2F26%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[作为一名程序员，相信大家对Linux操作系统都不会陌生。但是Linux系统那些繁杂的操作命令通常让我们很头疼，我也在网上查阅了很多资料，做了一些总结。这里将常用的一些Linux操作命令(主要是与文件相关的操作命令)整理如下： sudo这个SuperUserDo(简写成”sudo”)是Linux新手要使用的最重要的命令。需要根权限的每一个命令都需要这个sudo命令。你可以在需要根权限的每个命令之前使用sudo 1$ sudo su pwd12~/Documents$ pwd# 获取当前所在的路径(绝对路径) ls(list)借助ls(list)命令，终端就会显示你正在处理的那个目录里面的所有文件和文件夹。假设我在Home目录(也就是”~”)里面，想查看当前目录下的文件夹和文件。相应的命令如下图所示： 12~$ ls# 显示当前目录的所有文件和文件夹 上面是ls命令最基本的使用方式，下面我们再看看ls命令其他的使用方式。 12~$ ls -l# 输出详细信息 -l (long 的简写). 这个指令会打印出文件的权限 (-rw-rw-r-- 之后我们在细说这个), 用户名, 文件大小, 修改日期, 文件名 12~$ ls -a# -a (all 的简写) 显示所有文件 . 这里还会显示隐藏的文件 (以 . 开头的) 12~$ ls -lh# -lh (human), 直接 -l 不方便人看, 这个指令是为了方便给人观看的. 注意这里的文件大小使用了 K, MB, GB 之类概括 12~$ ls --help# 还有很多其他的功能, 我们可以通过 --help 来查看 cd更改目录(cd)是始终在终端中使用的主要命令。它是最基本的Linux命令之一。使用这个命令很简单。只要输入你想要从当前目录进入到的那个文件夹的名称(如果是多层，中间用”/“进行分隔)。如果想要返回上一级，只要将双圆点(..)作为参数。 假设我在Home目录(也就是”~”)中，想进入到在Home目录里面的Documents子目录。下面是我可以使用cd命令的方法： 12~$ cd Documents/# 跳转到对应的Documents目录 若果要想返回到上一级目录，只用将双圆点(..)作为相应的参数即可。如下图所示： 12~/Documents$ cd ..# 返回上一级目录 除了上面两个基本的命令之外，还有一些有趣的，我们来看看。 12~$ cd Documents/Folder1/# 去往子文件夹Folder1 12~/Documents/Folder1$ cd -# 返回你刚刚所在的目录(也就是你的上一条命令所在的目录) 12~/Documents/Folder1$ cd ../../# 向上返回两次(再往上返回可以依次类推) 12~/Documents/Folder1$ cd ~# 去往Home touchtouch 命令的意思的新建，它的使用很简单。我们先去往 Documents 的文件夹, 里面已经有了 folder1 和 file1, 如果我们想新建一个 file2 使用下面的语句就好(可以指定文件的扩展名)。一个空文件就这样建立好了。 12~/Documents$ touch file2.txt# 建立一个文件名为file2的空的文本文档 如果你想同时建立多个文件，输入多个文件的名字，以空格分开。 12~/Documents$ touch file3.txt file4.txt file5.txt# 同时建立三个空的文本文档(也可以不指定文件的扩展名) cp拷贝粘贴是我们为了组织整理文件而需要完成的重要任务。使用cp将帮助你从终端拷贝粘贴文件。首先，你确定想要拷贝的那个文件，然后输入目的地位置，即可粘贴文件。cp (copy) 是复制文件或者文件夹的指令, 常用的方式是复制 “老文件” 到 “新文件”。即： 1~$ cp 老文件 新文件 注意: 如果你将文件拷贝到任何新文件都需要根权限的目录，那么你就需要使用sudo命令。 下面是cp命令的一些常见操作。 12~/Documents$ cp file1 file1copy# 将file1复制成file1copy 123~/Documents$ cp -i file1 file1copy# -i (interactive) 注意: 如果 file1copy 已经存在, 它将会直接覆盖已存在的 file1copy, 如果要避免直接覆盖, 我们在 cp 后面加一个选项。# 在这句问句后面打上 “Yes”, “Y”, 或者任何大小写形式的 “y” 和 “yes”, 它将进行覆盖操作. 直接回车或者打其他字母, 就会放弃复制这项操作。 12~/Documents$ cp file1 Folder1/# 将file1复制到文件夹Folder1 12~/Documents$ cp -R Folder1/ Folder2/# 复制文件夹, 需要加上 -R (recursive) 12~/Documents$ cp file* Folder1/# 复制多个文件。复制名字部分相同的多个文件到某个文件夹, * 是说"你就找文件名前面是 file 的文件, 后面是什么名字无所谓" 12~/Documents$ cp file2.txt file5.txt Folder1/# 或者你可以单独选定几个文件, cp 会默认最后一个选项是要复制去的文件夹. 比如把 file2.txt 和 file5.txt 复制去 Folder1/ mv知道了 cp, mv就好理解多了, 基本是一样的。mv是剪切(移动)的命令。下面是mv命令的一些常见操作。 12~/Documents$ mv file1 Folder1/# 将file1移动到文件夹Folder1 12~/Documents$ mv file1 file1rename# 重命名文件file1为file1rename。因为移动文件到原始的地点, 但是以不同的文件名。所以这种做法不就是在重命名嘛! 12~/Documents$ mv -f file1 Folder2/# 将文件file1强制移动到Folder2文件夹下。如果目标文件已经存在，不会询问而会直接覆盖。 最后还是想要提一句, 如果想要查看使用说明, 直接在指令后面打上 --help就能查看. mkdir仅仅会更改目录还不全面。有时候，你想要创建一个新的文件夹或子文件夹。可以使用mkdir命令来做到这一点。只要在终端中将你的文件夹名称放在mkdir命令的后面即可。mkdir (make directory) 就是创建一个文件夹的意思, 使用起来很简单。 以下是mkdir命令的一些常见操作。 12~/Documents$ mkdir Folder2/# 在Documents文件夹下创建一个文件夹Folder2 12~/Documents$ mkdir Folder2/folder# 在文件夹Folder2里面再创建一个子文件夹folder rmdirrmdir(remove directory) 也就是字面的意思，即移除文件夹。不过这有一个前提条件. 这些要移除的文件夹必须是空的，不然会失败。所以如果想刚刚建立的那个 Folder2 就不能被移除, 因为里面有个 folder 文件夹。那么怎么移除有文件的文件夹呢？这里需要用到我们后面讲的rm命令。 要移除个空文件夹, 比如我在新建一个 Folder3, 然后移除。 12~/Documents$ rmdir Folder3# 删除文件夹Folder3(rmdir只能移除空文件夹！！！) rmrm这个命令可以移除你的文件，甚至移除你的目录。如果文件需要根权限才能移除，可以使用-f。你还可以使用-r来进行递归移除，从而移除你的文件夹。 注意: 执行了 rm以后是不能进行返回操作的, 请确保别执行像这样的操作 rm /，这会清空你的电脑。 12~/Documents$ rm file1# 删除单个文件filer1 12345~/Documents$ rm -i file2# -i 或 -I 有提示地移除文件 (为了避免误删)# -i 会每个要移除的文件都进行提示~/Documents$ rm -i file2 fil3 file4 file5# -I 超过3个文件才进行提示 123~/Documents$ rm -r Folder1/# -r 或 -R (recursively) 用来删文件夹# 和 rmdir 不同, rm -r 可以在文件夹中有文件的情况下删除这个文件夹. 比如我的 Folder1 里有 file1 和 file2 两个文件. rm命令其他的特点和cp命令差不多，比如用带相应的前缀或者后缀(或者不带，这样会清空当前文件夹下所有文件)加’*’来一次性删除多个文件。 nanonano是 linux 的一款文字编辑工具. 我们可以拿它来做最基本的 terminal 端的文本编辑, 甚至可以写代码。下面我们用 touch 创建一个 Python 脚本。如果大家不懂Python 也没关系，你就知道我们可以拿 nano来编辑文字或者脚本就好了。 12~/Documents$ touch p1.py# 在Documents目录下创建一个python文件 然后用 nano 执行这个 p1.py 文件，如下图所示： 12~/Documents$ nano p1.py# 用nano命令执行这个文件 它就会变成一个文本编辑器, 你在里面可以写上一些脚本。然后按 “Ctrl + x” 来保存和退出。如果提示你保存, 你就按一下 “y” 键, 然后回车, 你的文件就被保存下来了。 接着如果你在 terminal 中输入相关的执行python文件的命令，你就能看到 terminal 执行了你的 python 文件。 cat作为用户，你常常需要查看来自脚本的一些文档或代码。同样，其中一个Linux基本命令是cat命令。它会为你显示文件里面的文本。 cat(catenate) 可以用来显示文件内容, 或者是将某个文件里的内容写入到其他文件里。详细的操作见下面。 123~/Documents$ cat p1.py &gt; p2.py~/Documents$ cat p2.py# &gt; 将文件的内容放到另一个文件里，这里我们将p1.py的内容写入到p2.py里面。 1234~/Documents$ cat p1.py p2.py &gt; p3.py~/Documents$ cat p3.py# &gt; 将多个文件的内容打包一起放入另一个文件，这里我们将p1.py的内容和p1.py的内容一同写入到p2.py里面。# 在显示的时候，两个文件的内容会分开显示 123~/Documents$ cat p2.py &gt;&gt; p3.py~/Documents$ cat p3.py# &gt;&gt; 将内容添加在一个文件末尾，这里我们将p2.py的内容添加到p3.py的末尾。 head1234~/Documents$ head -n 5 p2.py# 查看文件的前几行(默认查看前10行)# head [-n number] filename# -n ：后面接数字，代表显示几行的意思 tail1234~/Documents$ tail -n 6 p3.py# 查看文件的后几行(默认查看倒数后10行)# tail [-n number] filename# -n ：后面接数字，代表显示几行的意思 apt-get就不同的发行版而言，这个命令各不相同。在基于Debian的Linux发行版中，想安装、移除和升级任何软件包，我们可以使用高级包装工具(APT)软件包管理器。apt-get命令可帮助你安装需要在Linux中运行的软件。这是个功能强大的命令行工具，可以执行安装、升级、甚至移除软件这类任务。 在其他发行版(比如Fedora和Centos)中，有不同的软件包管理器。Fedora过去有yum，但现在它有dnf。 1~ sudo apt-get update 1~ sudo dnf update 12~ sudo apt-get install &lt;package name&gt;# 安装相应的软件或工具 grep你需要找到一个文件，但是又记不得它的确切位置或路径。grep可以帮助你解决这个问题。你可以使用grep命令，根据给定的关键字帮助找到文件。 grep是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 1234567$ grep [-acinv] [--color=auto] 搜寻字符串 filename# -a ： 将 binary 文件以 text 文件的方式进行搜寻# -c ： 计算找到个数# -i ： 忽略大小写# -n ： 输出行号# -v ： 反向选择，亦即显示出 没有搜寻字符串内容 的那一行# --color=auto ：找到的关键字加颜色显示 12~/Documents$ grep hello p1.python# 在p1.py文件中搜索"hello"这个单词 范例：把含有 the 字符串的行提取出来(注意默认会有 –color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串) 1234567$ grep -n 'the' regular_express.txt# 以下为相应的显示结果# 8:I can't finish the test.# 12:the symbol '*' is represented as start.# 15:You are the best is mean you are the no. 1.# 16:The world Happy is the same with "glad".#18:google is the best tools for search keyword 因为 { 和 }在 shell 是有特殊意义的，因此必须要使用转义字符进行转义。 1$ grep -n 'go\&#123;2,5\&#125;g' regular_express.txt grep还有很多更强大的用法，后续会继续更新。当然，具体的用法可以通过grep --help进行查看。 poweroff有时候，你需要直接从终端来进行关机。这个命令就能完成这项任务，别忘了在命令的开头添加sudo，因为它需要根权限才能执行poweroff。 1~$ sudo poweroff 结束语好了，基本的Linux命令大概就这么多。它会帮助你在这个早期阶段开始使用Linux，借助这些基本的Linux命令，开始使用Linux，并且定个目标：每天学会使用1个至3个命令。后续我也会继续更新~]]></content>
      <categories>
        <category>Linux操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令整理]]></title>
    <url>%2F2018%2F04%2F24%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言碎碎念自从使用Git作为版本控制工具以来，通过教程学习、手册查阅方式了解了Git的相关原理和Git的命令，能够顺利使用。但由于还不熟练，实践经验也还不够丰富，每次遇到问题都需要重新搜索，多次下来十分麻烦。另一方面，查阅手册往往是不够的，因为手册只会告诉你什么命令做什么用，不会根据不同场景告诉你应该用什么命令。 所以在这篇文章中，我将常用的Git命令根据不同的使用场景做一个整理，加深印象的同时也方便自己日后进行查阅。 四个概念这里借用阮一峰老师的文章《常用Git命令清单》中的图。 几个专有名词的译名如下： Workspace: 工作区，也就是正在编辑的文件目录 Index / Stage: 暂存区 Repository: 本地仓库，.git文件夹管理的版本库 Remote: 远程仓库，也就是github.com上面的仓库 例如，在最常用的命令串中： 12345678$ git add &lt;file&gt;#添加工作区指定文件的改动到暂存区，"&lt;file&gt;"为"."时添加全部文件$ git commit -m "XXXX"#提交暂存区的所有内容到本地仓库的当前分支$ git push -u origin master#上传本地仓库到已关联的远程仓库 建立工程在工作目录中建立与远程仓库关联的Git工程主要有两种情况：第一种是由本地上传到远程仓库；第二种是从远程仓库克隆到本地。 本地上传在这种情况下，远程仓库应该是没有工程的。在本地工程文件夹下： 123456789101112$ git init#初始化一个Git仓库，此时当前目录会增加一个.git文件夹(此文件夹默认是隐藏的)，当前文件夹受到Git的管理，并默认创建master分支$ git add &lt;file&gt;#添加指定文件到暂存区，"&lt;file&gt;"为"."时表明添加当前目录的所有文件到暂存区$ git commit -m "XXXX"#提交暂存区的所有内容到本地仓库的当前分支$ git remote add origin &lt;url&gt;#为当前项目添加远程主机。#其中origin为自定义的远程主机名，url为远程主机的地址（推荐采用ssh协议） 此时已经建立了本地仓库与远程仓库的关联，可以通过git push推送上传。第一次推送采用： 12$ git push -u origin master#将本地master分支推送到远程同名分支（若不存在则新建），同时-u指定origin为默认主机名，之后若要上传到origin可省略它。 远程克隆这种情况下，远程仓库已经有工程，只需要在本地工程文件夹下用git clone命令克隆： 1$ git clone &lt;url&gt; 此时本地仓库已经与对应远程仓库建立关联，为主机名origin的地址。 克隆其他分支git clone命令默认克隆远程项目的master分支及其历史，若还需克隆别的分支，可通过以下方式进行（以克隆dev分支为例）： 12$ git checkout -b dev origin/dev#检出origin下的dev分支到本地新建的dev分支，并建立本地分支与远程分支的追踪关系 或者： 12345678$ git checkout -b dev#新建并切换到本地分支dev$ git branch --set-upstream-to=origin/dev dev#建立origin/dev远程分支和dev本地分支的追踪关系$ git pull#拉取本地分支dev对应的远程分支的最新状态 托管到新的远程仓库在克隆需要的内容后，有时会希望托管到新的远程仓库。此时可以增加新的远程主机名: 1$ git remote add &lt;new_remote_name&gt; &lt;url&gt; 或者干脆更改原来origin的地址： 1$ git remote origin set-url &lt;url&gt; 分支管理查看分支12345678$ git branch#查看本地分支$ git branch -r#查看远程分支$ git branch -a#查看所有本地分支和远程分支 新建本地分支新建分支（不切换）： 1$ git branch &lt;new_branch&gt; 新建分支并切换到新分支： 1234$ git checkout -b &lt;new_branch&gt;#相当于：$ git branch &lt;new_branch&gt;$ git checkout &lt;new_branch&gt; 删除本地分支12345$ git branch -d &lt;branch&gt;#删除分支前检查该分支是否有未提交或者未合并的内容$ git branch -D &lt;branch&gt;#强制删除该分支 新建远程分支相当于把远程未添加的本地分支push到远程： 12$ git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;#建议远程与本地分支同名，同名时可省略远程分支名 删除远程分支相当于push一个本地的空分支： 12$ git push origin :&lt;remote_branch&gt;#本地分支为空 或者用--delete： 1$ git push origin --delete &lt;remote_branch&gt; 合并分支12345$ git merge &lt;branch&gt;#快进合并（指针指向改变），合并&lt;branch&gt;到当前分支$ git merge --no-ff &lt;branch&gt;#合并&lt;branch&gt;到当前分支，在当前分支生成新节点，保证每个分支的独立演变史 撤销与版本回退撤销工作区修改有时修改工作区后，发现修改错误，希望回到原来未修改时（上一次提交或暂存）的状态。可以采用git checkout命令： 1234567$ git diff#查看工作区未提交（或为暂存）的文件的具体修改$ git checkout -- &lt;file&gt;#恢复工作区指定文件到上一次提交（或暂存）状态$ git checkout .#撤销所有工作区修改 撤销暂存12$ git reset HEAD &lt;file&gt;#将指定文件撤出暂存区 版本回退希望将版本库回退到之前的提交时，采用git reset命令： 12345678$ git log#查看之前的版本提交记录$ git reset HEAD^#回退到上一个提交版本，^^代表上两个版本，以此类推。（也可以用~2等代替）或$ git reset &lt;commitID&gt;#commitID可由git log查看得到 有必要整理一下git reset命令的三个参数： 123456789$ git reset --soft HEAD^#重置版本库头指针，且将这次提交之后的所有变更移动到暂存区$ git reset --mixed HEAD^#默认参数，等同于 git reset HEAD^#重置版本库头指针和暂存区，即这次提交之后的所有更改都留在工作区$ git reset --hard HEAD^#重置版本库头指针、暂存区和工作区，即这次提交之后的所有更改都不在存在于当前状态 在没有将之后的提交推送到远程仓库的情况下，git reset --hard是个很危险的操作。若是已经推送到远程仓库，使用git pull可以重新获得之后的版本提交。若是在没有远程备份时使用--hard进行版本回退，又想恢复到之后的版本，在一定时间内（一般为30天）可以通过git reflog查看操作id，再使用git reset --hard &lt;ID&gt;恢复。 stash储藏有时手头的工作进行到一半，需要切换分支做一些其他事情，可以采用git stash命令将当前的工作区储藏起来。 12345678910111213$ git stash#储藏当前工作区$ git stash list#查看当前的stash储藏栈$ git stash apply#应用栈顶的储藏内容，恢复工作区到之前的储藏状态$ git stash apply stash@&#123;2&#125;#应用指定储藏内容$ git stash pop#与apply类似，但从栈中删除该储藏内容 多人协作推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： 12345#默认推送的为master主分支$ git push origin master#如果要推送其他分支，将该分支对应的名字来替换master即可$ git push origin dev 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： 12$ git branch* master 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： 12#注意：本地分支名称最好与远程分支保持一致。$ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程。 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你对同样的文件也做了修改，并且试图推送。 这个时候会推送失败,因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单: 先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。 1$ git pull 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令 1$ git branch --set-upstream branch-name origin/branch-name 最后再将你改好的分支push到远程仓库。这就是多人协作的工作模式，一旦熟悉了，就非常简单。 其他状态查看1$ git status 任何情况下都可以使用git status命令查看当前的版本控制状态（包括工作区、暂存区、仓库区），并给出当前状态下可能会用到的命令提示。经常使用该命令是好习惯。 查看远程库信息1$ git remote -v 配置git用户123$ git config user.name "your name"$ git config user.email "email@example.com"#配置当前目录的git用户，加上--config参数时配置这台机器的所有git仓库 协议更改有时版本克隆是采用的是https协议，以至于每一次提交都需要输入用户名密码，很麻烦。而使用ssh协议就会方便很多，需要将当前的仓库协议进行更换。事实上，重置远程仓库名为ssh协议地址就可以了。 1$ git remote origin set-url git@example.com....]]></content>
      <categories>
        <category>版本控制之Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何更改Github上面托管的项目的默认显示语言]]></title>
    <url>%2F2018%2F04%2F22%2F%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9Github%E4%B8%8A%E9%9D%A2%E6%89%98%E7%AE%A1%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%BB%98%E8%AE%A4%E6%98%BE%E7%A4%BA%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[最近将自己一门课的课程大作业，也算是一个小项目demo，放到了GitHub上面，由于项目里面包含许多下载的html文件，导致html代码远远的超过自己写的python代码，于是GitHub默认也就显示是html。 这种对于我这种有强迫症的人来说，简直就是不能忍受的。于是我就各种上网找解决方案。终于，在不懈的努力之后，让我给找到了，在这里分享给大家。 导致这种情况的主要原因是GitHub是使用Linguist来检测你的项目所使用的语言，Linguist具体的作用我个人猜测应该就是：统计你这个项目里面哪一种语言的代码量最多，就把这种语言作为当前这个项目的主语言,也就是默认显示语言。这种做法显然是很不合理的，你比如像python这种支持函数式编程而且崇尚语法简洁优雅的解释型脚本语言，它的代码量远远比不过其他的编译型语言(比如C/C++/Java)。 那么到底如何来解决这个问题呢？解决办法如下： 使用.gitattributes配置文件 具体做法是这样的：在你的GitHub代码仓库的根目录界面新建一个.gitattributes配置文件，如下图所示： 然后打开这个文件：把默认的显示语言（也就是统计的代码量最多的语言）全部改成你这个项目本来的语言。例如： 123*.js linguist-language=Python *.css linguist-language=Python *.html linguist-language=Python 这几行代码的意思就是说：将以.js , .css , .html 为扩展名的文件都按照Python语言来统计。就是这么简单。这么直接！！！ 好了，改完这些之后保存，再回到GitHub主界面就会看到默认的展示语言已经变成python了。主要的步骤就是这样，希望能够帮助到大家。]]></content>
      <categories>
        <category>版本控制之Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
